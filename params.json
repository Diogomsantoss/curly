{"name":"Curly","tagline":"The Curly template language allows separating your logic from the structure of your HTML templates.","body":"Curly\r\n=======\r\n\r\nFree your views!\r\n\r\nCurly is a template language that completely separates structure and logic.\r\nInstead of interspersing your HTML with snippets of Ruby, all logic is moved\r\nto a presenter class, with only simple placeholders in the HTML.\r\n\r\nWhile the basic concepts are very similar to [Mustache](http://mustache.github.com/)\r\nor [Handlebars](http://handlebarsjs.com/), Curly is different in some key ways:\r\n\r\n- Instead of the template controlling the variable scope and looping through\r\n  data, all logic is left to the presenter object. This means that untrusted\r\n  templates can safely be executed, making Curly a possible alternative to\r\n  languages like [Liquid](http://liquidmarkup.org/).\r\n- Instead of implementing its own template resolution mechanism, Curly hooks\r\n  directly into Rails, leveraging the existing resolvers.\r\n- Because of the way it integrates with Rails, it is very easy to use partial\r\n  Curly templates to split out logic from a presenter. With Mustache, at least,\r\n  when integrating with Rails, it is common to return Hash objects from view\r\n  object methods that are in turn used by the template.\r\n\r\n\r\n\r\n### Is it ready to use in production?\r\n\r\nYes! While still a young project, it's being used in a rather large Rails app\r\nat Zendesk, where it performs admirably.\r\n\r\n\r\n\r\n### Table of Contents\r\n\r\n1. [Installing](#installing)\r\n2. [How to use Curly](#how-to-use-curly)\r\n    1. [Conditional blocks](#conditional-blocks)\r\n    2. [Escaping Curly syntax](#escaping-curly-syntax)\r\n3. [Presenters](#presenters)\r\n    1. [Layouts and Content Blocks](#layouts-and-content-blocks)\r\n    2. [Examples](#examples)\r\n4. [Caching](#caching)\r\n\r\n\r\nInstalling\r\n----------\r\n\r\nInstalling Curly is as simple as running `gem install curly-templates`. If you're\r\nusing Bundler to manage your dependencies, add this to your Gemfile\r\n\r\n```ruby\r\ngem 'curly-templates'\r\n```\r\n\r\n\r\nHow to use Curly\r\n----------------\r\n\r\nIn order to use Curly for a view or partial, use the suffix `.curly` instead of\r\n`.erb`, e.g. `app/views/posts/_comment.html.curly`. Curly will look for a\r\ncorresponding presenter class named `Posts::CommentPresenter`. By convention,\r\nthese are placed in `app/presenters/`, so in this case the presenter would\r\nreside in `app/presenters/posts/comment_presenter.rb`. Note that presenters\r\nfor partials are not prepended with an underscore.\r\n\r\nAdd some HTML to the partial template along with some Curly variables:\r\n\r\n```html\r\n<!-- app/views/posts/_comment.html.curly -->\r\n<div class=\"comment\">\r\n  <p>\r\n    {{author_link}} posted {{time_ago}} ago.\r\n  </p>\r\n\r\n  {{body}}\r\n\r\n  {{#author?}}\r\n    <p>{{deletion_link}}</p>\r\n  {{/author?}}\r\n</div>\r\n```\r\n\r\nThe presenter will be responsible for filling in the variables. Add the necessary\r\nRuby code to the presenter:\r\n\r\n```ruby\r\n# app/presenters/posts/comment_presenter.rb\r\nclass Posts::CommentPresenter < Curly::Presenter\r\n  presents :comment\r\n\r\n  def body\r\n    BlueCloth.new(@comment.body).to_html\r\n  end\r\n\r\n  def author_link\r\n    link_to @comment.author.name, @comment.author, rel: \"author\"\r\n  end\r\n  \r\n  def deletion_link\r\n    link_to \"Delete\", @comment, method: :delete\r\n  end\r\n\r\n  def time_ago\r\n    time_ago_in_words(@comment.created_at)\r\n  end\r\n  \r\n  def author?\r\n    @comment.author == current_user\r\n  end\r\nend\r\n```\r\n\r\nThe partial can now be rendered like any other, e.g. by calling\r\n\r\n```ruby\r\nrender 'comment', comment: comment\r\nrender comment\r\nrender collection: post.comments\r\n```\r\n\r\n\r\n### Conditional blocks\r\n\r\nIf there is some content you only want rendered under specific circumstances, you can\r\nuse _conditional blocks_. The `{{#admin?}}...{{/admin?}}` syntax will only render the\r\ncontent of the block if the `admin?` method on the presenter returns true, while the\r\n`{{^admin?}}...{{/admin?}}` syntax will only render the content if it returns false.\r\n\r\nBoth forms can be parameterized by a single argument: `{{#locale.en?}}...{{/locale.en?}}`\r\nwill only render the block if the `locale?` method on the presenter returns true given the\r\nargument `\"en\"`. Here's how to implement that method in the presenter:\r\n\r\n```ruby\r\nclass SomePresenter < Curly::Presenter\r\n  # Allows rendering content only if the locale matches a specified identifier.\r\n  def locale?(identifier)\r\n    current_locale == identifier\r\n  end\r\nend\r\n```\r\n\r\n\r\n### Escaping Curly syntax\r\n\r\nIn order to have `{{` appear verbatim in the rendered HTML, use the triple Curly escape syntax:\r\n\r\n```\r\nThis is {{{escaped}}.\r\n```\r\n\r\nYou don't need to escape the closing `}}`.\r\n\r\n\r\nPresenters\r\n----------\r\n\r\nPresenters are classes that inherit from `Curly::Presenter` – they're usually placed in\r\n`app/presenters/`, but you can put them anywhere you'd like. The name of the presenter\r\nclasses match the virtual path of the view they're part of, so if your controller is\r\nrendering `posts/show`, the `Posts::ShowPresenter` class will be used. Note that Curly\r\nis only used to render a view if a template can be found – in this case, at\r\n`app/views/posts/show.html.curly`.\r\n\r\nPresenters can declare a list of accepted parameters using the `presents` method:\r\n\r\n```ruby\r\nclass Posts::ShowPresenter < Curly::Presenter\r\n  presents :post\r\nend\r\n```\r\n\r\nA parameter can have a default value:\r\n\r\n```ruby\r\nclass Posts::ShowPresenter < Curly::Presenter\r\n  presents :post\r\n  presents :comment, default: nil\r\nend\r\n```\r\n\r\nAny public method defined on the presenter is made available to the template:\r\n\r\n```ruby\r\nclass Posts::ShowPresenter < Curly::Presenter\r\n  presents :post\r\n  \r\n  def title\r\n    @post.title\r\n  end\r\n  \r\n  def author_link\r\n    # You can call any Rails helper from within a presenter instance:\r\n    link_to author.name, profile_path(author), rel: \"author\"\r\n  end\r\n  \r\n  private\r\n  \r\n  # Private methods are not available to the template, so they're safe to\r\n  # use.\r\n  def author\r\n    @post.author\r\n  end\r\nend\r\n```\r\n\r\nPresenter methods can even take an argument. Say your Curly template has the content\r\n`{{t.welcome_message}}`, where `welcome_message` is an I18n key. The following presenter\r\nmethod would make the lookup work:\r\n\r\n```ruby\r\ndef t(key)\r\n  translate(key)\r\nend\r\n```\r\n\r\nThat way, simple ``functions'' can be added to the Curly language. Make sure these do not\r\nhave any side effects, though, as an important part of Curly is the idempotence of the\r\ntemplates.\r\n\r\n\r\n### Layouts and Content Blocks\r\n\r\nBoth layouts and content blocks (see [`content_for`](http://api.rubyonrails.org/classes/ActionView/Helpers/CaptureHelper.html#method-i-content_for))\r\nuse `yield` to signal that content can be inserted. Curly works just like ERB, so calling\r\n`yield` with no arguments will make the view usable as a layout, while passing a Symbol\r\nwill make it try to read a content block with the given name:\r\n\r\n```ruby\r\n# Given you have the following Curly template in app/views/layouts/application.html.curly\r\n#\r\n#   <html>\r\n#     <head>\r\n#       <title>{{title}}</title>\r\n#     </head>\r\n#     <body>\r\n#       <div id=\"sidebar\">{{sidebar}}</div>\r\n#       {{body}}\r\n#     </body>\r\n#   </html>\r\n#\r\nclass ApplicationLayout < Curly::Presenter\r\n  def title\r\n    \"You can use methods just like in any other presenter!\"\r\n  end\r\n  \r\n  def sidebar\r\n    # A view can call `content_for(:sidebar) { \"some HTML here\" }`\r\n    yield :sidebar\r\n  end\r\n  \r\n  def body\r\n    # The view will be rendered and inserted here:\r\n    yield\r\n  end\r\nend\r\n```\r\n\r\n\r\n### Examples\r\n\r\nHere is a simple Curly template – it will be looked up by Rails automatically.\r\n\r\n```html\r\n<!-- app/views/posts/show.html.curly -->\r\n<h1>{{title}}<h1>\r\n<p class=\"author\">{{author}}</p>\r\n<p>{{description}}</p>\r\n\r\n{{comment_form}}\r\n\r\n<div class=\"comments\">\r\n  {{comments}}\r\n</div>\r\n```\r\n\r\nWhen rendering the template, a presenter is automatically instantiated with the\r\nvariables assigned in the controller or the `render` call. The presenter declares\r\nthe variables it expects with `presents`, which takes a list of variables names.\r\n\r\n```ruby\r\n# app/presenters/posts/show_presenter.rb\r\nclass Posts::ShowPresenter < Curly::Presenter\r\n  presents :post\r\n\r\n  def title\r\n    @post.title\r\n  end\r\n\r\n  def author\r\n    link_to(@post.author.name, @post.author, rel: \"author\")\r\n  end\r\n\r\n  def description\r\n    Markdown.new(@post.description).to_html.html_safe\r\n  end\r\n\r\n  def comments\r\n    render 'comment', collection: @post.comments\r\n  end\r\n\r\n  def comment_form\r\n    if @post.comments_allowed?\r\n      render 'comment_form', post: @post\r\n    else\r\n      content_tag(:p, \"Comments are disabled for this post\")\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n\r\nCaching\r\n-------\r\n\r\nCaching is handled at two levels in Curly – statically and dynamically. Static caching\r\nconcerns changes to your code and templates introduced by deploys. If you do not wish\r\nto clear your entire cache every time you deploy, you need a way to indicate that some\r\nview, helper, or other piece of logic has changed.\r\n\r\nDynamic caching concerns changes that happen on the fly, usually made by your users in\r\nthe running system. You wish to cache a view or a partial and have it expire whenever\r\nsome data is updated – usually whenever a specific record is changed.\r\n\r\n\r\n### Dynamic Caching\r\n\r\nBecause of the way logic is contained in presenters, caching entire views or partials\r\nby the data they present becomes exceedingly straightforward. Simply define a\r\n`#cache_key` method that returns a non-nil object, and the return value will be used to\r\ncache the template.\r\n\r\nWhereas in ERB you would include the `cache` call in the template itself:\r\n\r\n```erb\r\n<% cache([@post, signed_in?]) do %>\r\n  ...\r\n<% end %>\r\n```\r\n\r\nIn Curly you would instead declare it in the presenter:\r\n\r\n```ruby\r\nclass Posts::ShowPresenter < Curly::Presenter\r\n  presents :post\r\n\r\n  def cache_key\r\n    [@post, signed_in?]\r\n  end\r\nend\r\n```\r\n\r\nLikewise, you can add a `#cache_duration` method if you wish to automatically expire\r\nthe fragment cache:\r\n\r\n```ruby\r\nclass Posts::ShowPresenter < Curly::Presenter\r\n  ...\r\n\r\n  def cache_duration\r\n    30.minutes\r\n  end\r\nend\r\n```\r\n\r\n\r\n### Static Caching\r\n\r\nStatic caching will only be enabled for presenters that define a non-nil `#cache_key`\r\nmethod (see [Dynamic Caching.](#dynamic-caching))\r\n\r\nIn order to make a deploy expire the cache for a specific view, set the version of the\r\nview to something new, usually by incrementing by one:\r\n\r\n```ruby\r\nclass Posts::ShowPresenter < Curly::Presenter\r\n  version 3\r\n\r\n  def cache_key\r\n    # Some objects\r\n  end\r\nend\r\n```\r\n\r\nThis will change the cache keys for all instances of that view, effectively expiring\r\nthe old cache entries.\r\n\r\nThis works well for views, or for partials that are rendered in views that themselves\r\nare not cached. If the partial is nested within a view that _is_ cached, however, the\r\nouter cache will not be expired. The solution is to register that the inner partial\r\nis a dependency of the outer one such that Curly can automatically deduce that the\r\nouter partial cache should be expired:\r\n\r\n```ruby\r\nclass Posts::ShowPresenter < Curly::Presenter\r\n  version 3\r\n  depends_on 'posts/comment'\r\n\r\n  def cache_key\r\n    # Some objects\r\n  end\r\nend\r\n\r\nclass Posts::CommentPresenter < Curly::Presenter\r\n  version 4\r\n  depends_on 'posts/comment'\r\n\r\n  def cache_key\r\n    # Some objects\r\n  end\r\nend\r\n```\r\n\r\nNow, if the version of `Posts::CommentPresenter` is bumped, the cache keys for both\r\npresenters would change. You can register any number of view paths with `depends_on`.\r\n\r\nIf you use [Cache Digests](https://github.com/rails/cache_digests), Curly will\r\nautomatically provide a list of dependencies. This will allow you to deploy changes\r\nto your templates and have the relevant caches automatically expire.\r\n\r\n\r\nThanks\r\n------\r\n\r\nThanks to [Zendesk](http://zendesk.com/) for sponsoring the work on Curly.\r\n\r\n\r\n### Contributors\r\n\r\n- Daniel Schierbeck ([@dasch](https://github.com/dasch))\r\n- Benjamin Quorning ([@bquorning](https://github.com/bquorning))\r\n- Jeremy Rodi ([@redjazz96](https://github.com/redjazz96))\r\n\r\n\r\nBuild Status\r\n------------\r\n\r\n[![Build Status](https://travis-ci.org/zendesk/curly.png?branch=master)](https://travis-ci.org/zendesk/curly)\r\n\r\n\r\nCopyright and License\r\n---------------------\r\n\r\nCopyright (c) 2013 Daniel Schierbeck (@dasch), Zendesk Inc.\r\n\r\nLicensed under the [Apache License Version 2.0](http://www.apache.org/licenses/LICENSE-2.0).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}